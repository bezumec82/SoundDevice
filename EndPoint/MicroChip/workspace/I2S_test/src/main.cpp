#include "main.h"

#define REG_W_ERR   PRINT_ERR("Can't change I2SC reg. bits.\n")

#define IMCKDIV(n)      n-1

int main(/*int argc, char * argv[]*/) {
    cout << "Starting I2SC test." << endl;
    I2SC * i2s = new I2SC(0);

    /* I2SC Control Register */
    if (i2s->write_reg_bits("I2SC_CR", "SWRST",          0x1     ) < 0)  { REG_W_ERR; };
    if (i2s->write_reg_bits("I2SC_CR", "RXDIS",          0x1     ) < 0)  { REG_W_ERR; };
    if (i2s->write_reg_bits("I2SC_CR", "TXDIS",          0x1     ) < 0)  { REG_W_ERR; };
    if (i2s->write_reg_bits("I2SC_CR", "CKDIS",          0x1     ) < 0)  { REG_W_ERR; };

    /**********************/
    /* I2SC Mode Register */
    /**********************/
    /* 1    MASTER      Bit clock and word select/frame synchronization generated by I2SC from MCK and output to I2SC_CK and I2SC_WS pins.
     *                  Peripheral clock or GCLK is output as master clock on I2SC_MCK if I2SC_MR.IMCKMODE is set.
     * 0    SLAVE       I2SC_CK and I2SC_WS pin inputs used as bit clock and word select/frame synchronization.
     */
    if (i2s->write_reg_bits("I2SC_MR", "MODE",           0x1     ) < 0)  { REG_W_ERR; };

    /* 0    32_BITS     Data length is set to 32 bits */
    /* 4    16_BITS     Data length is set to 16 bits */
    if (i2s->write_reg_bits("I2SC_MR", "DATALENGTH",     0x0     ) < 0)  { REG_W_ERR; };

    /* 0    I2S         I2S format, stereo with I2SC_WS low for left channel, and MSB of sample starting one I2SC_CK period after I2SC_WS edge
     * 1    LJ          Left-justified format, stereo with I2SC_WS high for left channel, and MSB of sample starting on I2SC_WS edge
     * */
    if (i2s->write_reg_bits("I2SC_MR", "FORMAT",         0x0     ) < 0)  { REG_W_ERR; };

    /* 0                Stereo */
    if (i2s->write_reg_bits("I2SC_MR", "RXMONO",         0x0     ) < 0)  { REG_W_ERR; };

    /* 0                Normal mode */
    if (i2s->write_reg_bits("I2SC_MR", "RXLOOP",         0x0     ) < 0)  { REG_W_ERR; };

    /* 0                Stereo */
    if (i2s->write_reg_bits("I2SC_MR", "TXMONO",         0x0     ) < 0)  { REG_W_ERR; };

    /* 0                Zero sample transmitted when underrun. */
    if (i2s->write_reg_bits("I2SC_MR", "TXSAME",         0x0     ) < 0)  { REG_W_ERR; };



    /* 0    M2SF32      Sample frequency ratio set to 32
     * 1    M2SF64      Sample frequency ratio set to 64
     * 2    M2SF96      Sample frequency ratio set to 96
     * 3    M2SF128     Sample frequency ratio set to 128
     * 5    M2SF192     Sample frequency ratio set to 192
     * 23   M2SF768     Sample frequency ratio set to 768
     * 47   M2SF1536    Sample frequency ratio set to 1536
     * [2 x 16 × (IMCKFS + 1)] / (IMCKDIV + 1) = 2 * 16 * (23 + 1)/(0 + 1) = 768
     * (12288/768 = 16kHz)
     */
    if (i2s->write_reg_bits("I2SC_MR", "IMCKFS",         47      ) < 0)  { REG_W_ERR; }; /* Master Clock to Fs Ratio */

    /* 0                No master clock generated (Selected Clock drives I2SC_CK output).
     * 1                Master clock generated (internally generated clock is used as I2SC_MCK output).
     */
    if (i2s->write_reg_bits("I2SC_MR", "IMCKMODE",       0x1     ) < 0)  { REG_W_ERR; };

    /* 0                I2SC_WS slot is 32 bits wide for DATALENGTH = 18/20/24 bits.*/
    if (i2s->write_reg_bits("I2SC_MR", "IWS",            0x0     ) < 0)  { REG_W_ERR; };


    /* Selected Clock to I2SC Master Clock Ratio
     *      I2SC_MCK    Master clock output frequency is Selected Clock divided by (IMCKDIV + 1).
     * Do not write a ‘0’ to this field. Should be written last!
     */
    if (i2s->write_reg_bits("I2SC_MR", "IMCKDIV",        0x1     ) < 0)  { REG_W_ERR; };

    /* I2SC Interrupt Disable Register */
    if (i2s->write_reg_bits("I2SC_IDR", "RXRDY",         0x1     ) < 0)  { REG_W_ERR; }; /*!< Receiver Ready Interrupt Disable */
    if (i2s->write_reg_bits("I2SC_IDR", "RXOR",          0x1     ) < 0)  { REG_W_ERR; }; /*!< Receiver Overrun Interrupt Disable */
    if (i2s->write_reg_bits("I2SC_IDR", "TXRDY",         0x1     ) < 0)  { REG_W_ERR; }; /*!< Transmit Ready Interrupt Disable */
    if (i2s->write_reg_bits("I2SC_IDR", "TXUR",          0x1     ) < 0)  { REG_W_ERR; }; /*!< Transmit Underflow Interrupt Disable */

    /* I2SC Control Register */
    if (i2s->write_reg_bits("I2SC_CR", "RXEN",           0x1     ) < 0)  { REG_W_ERR; };
    if (i2s->write_reg_bits("I2SC_CR", "TXEN",           0x1     ) < 0)  { REG_W_ERR; };
    if (i2s->write_reg_bits("I2SC_CR", "CKEN",           0x1     ) < 0)  { REG_W_ERR; };

    i2s->read_all_regs();

#if (0)
    uint32_t txrdy = 0;
    for (int i = 0; i < 16*16; i++)
    {
        i2s->read_reg_bits("I2SC_SR", "TXRDY", &txrdy);
        if (txrdy)
        {
            if (i2s->write_reg_bits("I2SC_THR", "THR", 0xFFFF0000) < 0)  { REG_W_ERR; };
        }
        else
        {
            usleep(1); printf("!");
        }
    } //end for
#endif

#if (0)
#define BUF_SIZE    4096
#define CICLES      16

    unsigned int buf1[BUF_SIZE]{ 0 };
    unsigned int buf2[BUF_SIZE]{ 0 };
    for (int i = 0; i < BUF_SIZE; i++)
    {
        //i%2 ? buf1[i] = 0xffff0000 : buf1[i] = 0xaaaa0000;
        //i%2 ? buf2[i] = 0x0000ffff : buf2[i] = 0x0000aaaa;
        buf1[i] =   i<<16;
//        buf2[i] = i;
    }
    for (int j = 0; j < CICLES; j++)
    {
        i2s->write( (void *) &buf1 , BUF_SIZE*sizeof(int));
//        i2s->write( reinterpret_cast<void *> (&buf2) , BUF_SIZE*sizeof(int));
    }

    //i2s->read_all_regs();
#endif

    delete i2s;
    return (EXIT_SUCCESS);

}

/*
for i in `seq 1 10`;
do
    echo\
    12345678901234567890123456789012345678901234567890123456789012345678901234567890\
    > /dev/i2s0
done
dd if=/dev/urandom of=/dev/i2s0 count=1 bs=4KB
 */
